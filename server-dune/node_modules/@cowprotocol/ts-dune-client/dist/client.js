"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DuneClient = void 0;
const responseTypes_1 = require("./responseTypes");
const cross_fetch_1 = require("cross-fetch");
const utils_1 = require("./utils");
const loglevel_1 = require("loglevel");
const utils_2 = require("./utils");
const BASE_URL = "https://api.dune.com/api/v1";
const TERMINAL_STATES = [
    responseTypes_1.ExecutionState.CANCELLED,
    responseTypes_1.ExecutionState.COMPLETED,
    responseTypes_1.ExecutionState.FAILED,
];
// This class implements all the routes defined in the Dune API Docs: https://dune.com/docs/api/
class DuneClient {
    apiKey;
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    async _handleResponse(responsePromise) {
        const apiResponse = await responsePromise
            .then((response) => {
            if (!response.ok) {
                loglevel_1.default.error(utils_2.logPrefix, `response error ${response.status} - ${response.statusText}`);
            }
            return response.json();
        })
            .catch((error) => {
            loglevel_1.default.error(utils_2.logPrefix, `caught unhandled response error ${JSON.stringify(error)}`);
            throw error;
        });
        if (apiResponse.error) {
            loglevel_1.default.error(utils_2.logPrefix, `error contained in response ${JSON.stringify(apiResponse)}`);
            if (apiResponse.error instanceof Object) {
                throw new responseTypes_1.DuneError(apiResponse.error.type);
            }
            else {
                throw new responseTypes_1.DuneError(apiResponse.error);
            }
        }
        return apiResponse;
    }
    async _get(url) {
        loglevel_1.default.debug(utils_2.logPrefix, `GET received input url=${url}`);
        const response = (0, cross_fetch_1.default)(url, {
            method: "GET",
            headers: {
                "x-dune-api-key": this.apiKey,
            },
        });
        return this._handleResponse(response);
    }
    async _post(url, params) {
        loglevel_1.default.debug(utils_2.logPrefix, `POST received input url=${url}, params=${JSON.stringify(params)}`);
        // Transform Query Parameter list into "dict"
        const reducedParams = params?.reduce((acc, { name, value }) => ({ ...acc, [name]: value }), {});
        const response = (0, cross_fetch_1.default)(url, {
            method: "POST",
            body: JSON.stringify({ query_parameters: reducedParams || {} }),
            headers: {
                "x-dune-api-key": this.apiKey,
            },
        });
        return this._handleResponse(response);
    }
    async execute(queryID, parameters) {
        const response = await this._post(`${BASE_URL}/query/${queryID}/execute`, parameters);
        loglevel_1.default.debug(utils_2.logPrefix, `execute response ${JSON.stringify(response)}`);
        return response;
    }
    async getStatus(jobID) {
        const response = await this._get(`${BASE_URL}/execution/${jobID}/status`);
        loglevel_1.default.debug(utils_2.logPrefix, `get_status response ${JSON.stringify(response)}`);
        return response;
    }
    async getResult(jobID) {
        const response = await this._get(`${BASE_URL}/execution/${jobID}/results`);
        loglevel_1.default.debug(utils_2.logPrefix, `get_result response ${JSON.stringify(response)}`);
        return response;
    }
    async cancelExecution(jobID) {
        const { success } = await this._post(`${BASE_URL}/execution/${jobID}/cancel`);
        return success;
    }
    async refresh(queryID, parameters, pingFrequency = 5) {
        loglevel_1.default.info(utils_2.logPrefix, `refreshing query https://dune.com/queries/${queryID} with parameters ${JSON.stringify(parameters)}`);
        const { execution_id: jobID } = await this.execute(queryID, parameters);
        let { state } = await this.getStatus(jobID);
        while (!TERMINAL_STATES.includes(state)) {
            loglevel_1.default.info(utils_2.logPrefix, `waiting for query execution ${jobID} to complete: current state ${state}`);
            await (0, utils_1.sleep)(pingFrequency);
            state = (await this.getStatus(jobID)).state;
        }
        if (state === responseTypes_1.ExecutionState.COMPLETED) {
            return this.getResult(jobID);
        }
        else {
            const message = `refresh (execution ${jobID}) yields incomplete terminal state ${state}`;
            // TODO - log the error in constructor
            loglevel_1.default.error(utils_2.logPrefix, message);
            throw new responseTypes_1.DuneError(message);
        }
    }
}
exports.DuneClient = DuneClient;
